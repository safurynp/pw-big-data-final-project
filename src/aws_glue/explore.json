{
	"jobConfig": {
		"name": "explore",
		"description": "",
		"role": "arn:aws:iam::363710412655:role/LabRole",
		"command": "glueetl",
		"version": "4.0",
		"runtime": null,
		"workerType": "G.1X",
		"numberOfWorkers": "5",
		"maxCapacity": 5,
		"maxRetries": 0,
		"timeout": 2880,
		"maxConcurrentRuns": 1,
		"security": "none",
		"scriptName": "explore.py",
		"scriptLocation": "s3://aws-glue-assets-363710412655-us-east-1/scripts/",
		"language": "python-3",
		"spark": false,
		"jobParameters": [],
		"tags": [],
		"jobMode": "NOTEBOOK_MODE",
		"createdOn": "2024-01-05T12:22:03.740Z",
		"developerMode": false,
		"connectionsList": [],
		"temporaryDirectory": "s3://aws-glue-assets-363710412655-us-east-1/temporary/",
		"glueHiveMetastore": true,
		"etlAutoTuning": false,
		"pythonShellPrebuiltLibraryOption": "analytics",
		"flexExecution": false,
		"minFlexWorkers": null,
		"sourceControlDetails": {
			"Provider": "GITHUB",
			"Repository": "",
			"Branch": ""
		},
		"bookmark": "",
		"metrics": "",
		"observabilityMetrics": "",
		"logging": "",
		"sparkPath": "",
		"serverEncryption": false,
		"pythonPath": "",
		"dependentPath": "",
		"referencedPath": "",
		"etlAutoScaling": false,
		"etlAutoTuningJobRules": "",
		"pythonVersion": ""
	},
	"hasBeenSaved": false,
	"script": "\nimport sys\nfrom awsglue.transforms import *\nfrom awsglue.utils import getResolvedOptions\nfrom pyspark.context import SparkContext\nfrom awsglue.context import GlueContext\nfrom awsglue.job import Job\n  \nsc = SparkContext.getOrCreate()\nglueContext = GlueContext(sc)\nspark = glueContext.spark_session\njob = Job(glueContext)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_players')\ndyf.printSchema()\natp_players_df = dyf.toDF()\natp_players_df.show(n=5)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_players')\ndyf.printSchema()\nwta_players_df = dyf.toDF()\nwta_players_df.show(n=5)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_rankings')\ndyf.printSchema()\natp_rankings_df = dyf.toDF()\natp_rankings_df.show(n=5)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_rankings')\ndyf.printSchema()\nwta_rankings_df = dyf.toDF()\nwta_rankings_df.show(n=5)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_matches')\ndyf.printSchema()\natp_matches_df = dyf.toDF()\natp_matches_df.show(n=1, vertical=True)\ndyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_matches')\ndyf.printSchema()\nwta_matches_df = dyf.toDF()\nwta_matches_df.show(n=1, vertical=True)\n# Print unique 'draw_size' values\nunique_values = wta_matches_df.select('draw_size').distinct().collect()\nfor row in unique_values:\n    try:\n        print(row[0][0])\n    except Exception as e:\n        print(e)\n# Cast all 'draw_size' to long, if not castable then set to null\ndyf = dyf.resolveChoice(specs = [('draw_size', 'cast:long')])\ndyf.printSchema()\nwta_matches_df = dyf.toDF()\nfrom pyspark.sql import functions as F\n\n# Get the maximum player_id from atp_players_df\nmax_atp_player_id = atp_players_df.agg({\"player_id\": \"max\"}).collect()[0][0]\nprint(max_atp_player_id)\n\n\nfrom pyspark.sql.window import Window\n\n# Create a window function to generate new IDs starting from max_atp_player_id + 1\nw = Window.orderBy(F.monotonically_increasing_id())\n\n# Add a new column 'new_player_id' starting from (max_atp_player_id + 1) and rename/drop columns\nwta_players_df = wta_players_df.withColumn('new_player_id', F.row_number().over(w) + max_atp_player_id) \\\n                               .withColumnRenamed('player_id', 'old_player_id') \\\n                               .withColumnRenamed('new_player_id', 'player_id')\nwta_players_df.printSchema()\nwta_players_df.show(n=5)\n\n# DataFrame wta_rankings: Change 'player' column to 'player_id'\nwta_rankings_df = wta_rankings_df.join(wta_players_df, on=wta_rankings_df.player == wta_players_df.old_player_id, how='left') \\\n                                 .select(wta_rankings_df['*'], wta_players_df['player_id']) \\\n                                 .drop('player')\nwta_rankings_df.printSchema()\nwta_rankings_df.show(n=5)\n# DataFrame wta_matches: Change 'winner_id' and 'loser_id' columns to follow the new 'player_id'\nwta_matches_df = wta_matches_df.join(wta_players_df, on=wta_matches_df.winner_id == wta_players_df.old_player_id, how='left') \\\n                               .select(wta_matches_df['*'], wta_players_df['player_id']) \\\n                               .drop('winner_id') \\\n                               .withColumnRenamed('player_id', 'winner_id')\nwta_matches_df = wta_matches_df.join(wta_players_df, on=wta_matches_df.loser_id == wta_players_df.old_player_id, how='left') \\\n                               .select(wta_matches_df['*'], wta_players_df['player_id']) \\\n                               .drop('loser_id') \\\n                               .withColumnRenamed('player_id', 'loser_id')\nwta_matches_df.printSchema()\nwta_matches_df.show(n=1, vertical=True)\n# Merge ATP and WTA players data (drop 'old_player_id' from WTA data first)\nwta_players_df = wta_players_df.drop('old_player_id')\nplayers_df = atp_players_df.union(wta_players_df)\n\n# Merge ATP and WTA rankings data (rename 'player' column to 'player_id' and add 'tours' column to ATP data)\nfrom pyspark.sql.functions import lit\natp_rankings_df = atp_rankings_df.withColumnRenamed('player', 'player_id')\natp_rankings_df = atp_rankings_df.withColumn('tours', lit(None).cast('int'))\nrankings_df = atp_rankings_df.union(wta_rankings_df)\n\n# Merge ATP and WTA matches data\nmatches_df = atp_matches_df.union(wta_matches_df)\nfrom pyspark.sql.functions import col, to_date\nplayers_df = players_df.withColumn('dob', to_date(col('dob'), 'yyyyMMdd'))\nrankings_df = rankings_df.withColumn('ranking_date', to_date(col('ranking_date'), 'yyyyMMdd'))\nmatches_df = matches_df.withColumn('tourney_date', to_date(col('tourney_date'), 'yyyyMMdd'))\nplayers_df.printSchema()\nfrom pyspark.sql.functions import expr\n\n# Split the 'score' string by empty space and save as an array\nmatches_df = matches_df.withColumn('split_score', F.split('score', ' '))\n\n# Extract the first character of each element in the array, cast to int, and sum\nmatches_df = matches_df.withColumn('winner_games', F.expr(\"aggregate(split_score, 0, (acc, x) -> acc + cast(substr(x, 1, 1) as int))\"))\n\n# Extract the last character of each element in the array, cast to int, and sum\nmatches_df = matches_df.withColumn('loser_games', F.expr(\"aggregate(split_score, 0, (acc, x) -> acc + cast(substr(x, -1, 1) as int))\"))\n\nmatches_df = matches_df.drop('split_score')\n\nmatches_df.show(n=2, vertical=True)\n\nmatches_df.printSchema()\n# Write the DataFrames to S3 in a parquet format\nmatches_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/matches\")\nplayers_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/players\")\nrankings_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/rankings\")\njob.commit()",
	"notebook": {
		"metadata": {
			"kernelspec": {
				"name": "glue_pyspark",
				"display_name": "Glue PySpark",
				"language": "python"
			},
			"language_info": {
				"name": "Python_Glue_Session",
				"mimetype": "text/x-python",
				"codemirror_mode": {
					"name": "python",
					"version": 3
				},
				"pygments_lexer": "python3",
				"file_extension": ".py"
			}
		},
		"nbformat_minor": 4,
		"nbformat": 4,
		"cells": [
			{
				"cell_type": "markdown",
				"source": "# AWS Glue Studio Notebook\n##### You are now running a AWS Glue Studio notebook; To start using your notebook you need to start an AWS Glue Interactive Session.\n",
				"metadata": {
					"editable": true,
					"trusted": true
				}
			},
			{
				"cell_type": "markdown",
				"source": "####  Run this cell to set up and start your interactive session.\n",
				"metadata": {
					"editable": true,
					"trusted": true
				}
			},
			{
				"cell_type": "code",
				"source": "%idle_timeout 2880\n%glue_version 4.0\n%worker_type G.1X\n%number_of_workers 5\n\nimport sys\nfrom awsglue.transforms import *\nfrom awsglue.utils import getResolvedOptions\nfrom pyspark.context import SparkContext\nfrom awsglue.context import GlueContext\nfrom awsglue.job import Job\n  \nsc = SparkContext.getOrCreate()\nglueContext = GlueContext(sc)\nspark = glueContext.spark_session\njob = Job(glueContext)",
				"metadata": {
					"trusted": true,
					"editable": true
				},
				"execution_count": 1,
				"outputs": [
					{
						"name": "stdout",
						"text": "Welcome to the Glue Interactive Sessions Kernel\nFor more information on available magic commands, please type %help in any new cell.\n\nPlease view our Getting Started page to access the most up-to-date information on the Interactive Sessions kernel: https://docs.aws.amazon.com/glue/latest/dg/interactive-sessions.html\nInstalled kernel version: 1.0.2 \nCurrent idle_timeout is None minutes.\nidle_timeout has been set to 2880 minutes.\nSetting Glue version to: 4.0\nPrevious worker type: None\nSetting new worker type to: G.1X\nPrevious number of workers: None\nSetting new number of workers to: 5\nTrying to create a Glue session for the kernel.\nSession Type: glueetl\nWorker Type: G.1X\nNumber of Workers: 5\nSession ID: 22db692c-3cb1-4177-ba68-17fdc200f9d2\nApplying the following default arguments:\n--glue_kernel_version 1.0.2\n--enable-glue-datacatalog true\nWaiting for session 22db692c-3cb1-4177-ba68-17fdc200f9d2 to get into ready status...\nSession 22db692c-3cb1-4177-ba68-17fdc200f9d2 has been created.\n\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Create a DynamicFrame from a table in the AWS Glue Data Catalog and display its schema\n#### Later convert the DynamicFrame to a Spark DataFrame and display a sample of the data",
				"metadata": {
					"editable": true,
					"tags": [],
					"trusted": true
				}
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_players')\ndyf.printSchema()\natp_players_df = dyf.toDF()\natp_players_df.show(n=5)",
				"metadata": {
					"trusted": true,
					"editable": true
				},
				"execution_count": 46,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- player_id: long\n|-- name_first: string\n|-- name_last: string\n|-- hand: string\n|-- dob: long\n|-- ioc: string\n|-- height: long\n|-- wikidata_id: string\n\n+---------+----------+---------+----+--------+---+------+-----------+\n|player_id|name_first|name_last|hand|     dob|ioc|height|wikidata_id|\n+---------+----------+---------+----+--------+---+------+-----------+\n|   100001|   Gardnar|   Mulloy|   R|19131122|USA|   185|     Q54544|\n|   100002|    Pancho|   Segura|   R|19210620|ECU|   168|     Q54581|\n|   100003|     Frank|  Sedgman|   R|19271002|AUS|   180|    Q962049|\n|   100004|  Giuseppe|    Merlo|   R|19271011|ITA|  null|   Q1258752|\n|   100005|   Richard| Gonzalez|   R|19280509|USA|   188|     Q53554|\n+---------+----------+---------+----+--------+---+------+-----------+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_players')\ndyf.printSchema()\nwta_players_df = dyf.toDF()\nwta_players_df.show(n=5)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 47,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- player_id: long\n|-- name_first: string\n|-- name_last: string\n|-- hand: string\n|-- ioc: string\n|-- wikidata_id: string\n|-- dob: long\n|-- height: long\n\n+---------+----------+---------+----+---+-----------+--------+------+\n|player_id|name_first|name_last|hand|ioc|wikidata_id|     dob|height|\n+---------+----------+---------+----+---+-----------+--------+------+\n|   113190|     Bobby|    Riggs|   U|USA|           |    null|  null|\n|   200000|         X|        X|   U|UNK|           |19000000|  null|\n|   200001|   Martina|   Hingis|   R|SUI|    Q134720|19800930|   170|\n|   200002|   Mirjana|    Lucic|   R|CRO|    Q239686|19820309|   181|\n|   200003|   Justine|    Henin|   R|BEL|     Q11682|19820601|   167|\n+---------+----------+---------+----+---+-----------+--------+------+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_rankings')\ndyf.printSchema()\natp_rankings_df = dyf.toDF()\natp_rankings_df.show(n=5)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 48,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- ranking_date: long\n|-- rank: long\n|-- player: long\n|-- points: long\n\n+------------+----+------+------+\n|ranking_date|rank|player|points|\n+------------+----+------+------+\n|    20000110|   1|101736|  4135|\n|    20000110|   2|102338|  2915|\n|    20000110|   3|101948|  2419|\n|    20000110|   4|103017|  2184|\n|    20000110|   5|102856|  2169|\n+------------+----+------+------+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_rankings')\ndyf.printSchema()\nwta_rankings_df = dyf.toDF()\nwta_rankings_df.show(n=5)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 49,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- ranking_date: long\n|-- rank: long\n|-- player: long\n|-- points: long\n|-- tours: long\n\n+------------+----+------+------+-----+\n|ranking_date|rank|player|points|tours|\n+------------+----+------+------+-----+\n|    20000101|   1|200001|  6074| null|\n|    20000103|   1|200001|  6074| null|\n|    20000110|   1|200001|  6074| null|\n|    20000117|   1|200001|  6003| null|\n|    20000124|   1|200001|  6003| null|\n+------------+----+------+------+-----+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='atp_matches')\ndyf.printSchema()\natp_matches_df = dyf.toDF()\natp_matches_df.show(n=1, vertical=True)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 50,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- tourney_id: string\n|-- tourney_name: string\n|-- surface: string\n|-- draw_size: long\n|-- tourney_level: string\n|-- tourney_date: long\n|-- match_num: long\n|-- winner_id: long\n|-- winner_entry: string\n|-- winner_name: string\n|-- winner_hand: string\n|-- winner_ht: long\n|-- winner_ioc: string\n|-- winner_age: double\n|-- loser_id: long\n|-- loser_entry: string\n|-- loser_name: string\n|-- loser_hand: string\n|-- loser_ht: long\n|-- loser_ioc: string\n|-- loser_age: double\n|-- score: string\n|-- best_of: long\n|-- round: string\n|-- minutes: long\n|-- w_ace: long\n|-- w_df: long\n|-- w_svpt: long\n|-- w_1stin: long\n|-- w_1stwon: long\n|-- w_2ndwon: long\n|-- w_svgms: long\n|-- w_bpsaved: long\n|-- w_bpfaced: long\n|-- l_ace: long\n|-- l_df: long\n|-- l_svpt: long\n|-- l_1stin: long\n|-- l_1stwon: long\n|-- l_2ndwon: long\n|-- l_svgms: long\n|-- l_bpsaved: long\n|-- l_bpfaced: long\n|-- winner_rank: long\n|-- winner_rank_points: long\n|-- loser_rank: long\n|-- loser_rank_points: long\n|-- loser_seed: long\n|-- winner_seed: long\n\n-RECORD 0-----------------------------\n tourney_id         | 1968-2029       \n tourney_name       | Dublin          \n surface            | Grass           \n draw_size          | 32              \n tourney_level      | A               \n tourney_date       | 19680708        \n match_num          | 270             \n winner_id          | 112411          \n winner_entry       |                 \n winner_name        | Doug Smith      \n winner_hand        | U               \n winner_ht          | null            \n winner_ioc         | AUS             \n winner_age         | null            \n loser_id           | 110196          \n loser_entry        |                 \n loser_name         | Peter Ledbetter \n loser_hand         | U               \n loser_ht           | null            \n loser_ioc          | IRL             \n loser_age          | 24.0            \n score              | 6-1 7-5         \n best_of            | 3               \n round              | R32             \n minutes            | null            \n w_ace              | null            \n w_df               | null            \n w_svpt             | null            \n w_1stin            | null            \n w_1stwon           | null            \n w_2ndwon           | null            \n w_svgms            | null            \n w_bpsaved          | null            \n w_bpfaced          | null            \n l_ace              | null            \n l_df               | null            \n l_svpt             | null            \n l_1stin            | null            \n l_1stwon           | null            \n l_2ndwon           | null            \n l_svgms            | null            \n l_bpsaved          | null            \n l_bpfaced          | null            \n winner_rank        | null            \n winner_rank_points | null            \n loser_rank         | null            \n loser_rank_points  | null            \n loser_seed         | null            \n winner_seed        | null            \nonly showing top 1 row\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "dyf = glueContext.create_dynamic_frame.from_catalog(database='raw-data-crawler-database', table_name='wta_matches')\ndyf.printSchema()\nwta_matches_df = dyf.toDF()\nwta_matches_df.show(n=1, vertical=True)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 51,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- tourney_id: string\n|-- tourney_name: string\n|-- surface: string\n|-- draw_size: choice\n|    |-- long\n|    |-- string\n|-- tourney_level: string\n|-- tourney_date: long\n|-- match_num: long\n|-- winner_id: long\n|-- winner_seed: string\n|-- winner_entry: string\n|-- winner_name: string\n|-- winner_hand: string\n|-- winner_ioc: string\n|-- winner_age: double\n|-- loser_id: long\n|-- loser_seed: string\n|-- loser_entry: string\n|-- loser_name: string\n|-- loser_hand: string\n|-- loser_ioc: string\n|-- loser_age: double\n|-- score: string\n|-- best_of: long\n|-- round: string\n|-- winner_ht: long\n|-- loser_ht: long\n|-- minutes: long\n|-- w_ace: long\n|-- w_df: long\n|-- w_svpt: long\n|-- w_1stin: long\n|-- w_1stwon: long\n|-- w_2ndwon: long\n|-- w_svgms: long\n|-- w_bpsaved: long\n|-- w_bpfaced: long\n|-- l_ace: long\n|-- l_df: long\n|-- l_svpt: long\n|-- l_1stin: long\n|-- l_1stwon: long\n|-- l_2ndwon: long\n|-- l_svgms: long\n|-- l_bpsaved: long\n|-- l_bpfaced: long\n|-- winner_rank: long\n|-- winner_rank_points: long\n|-- loser_rank: long\n|-- loser_rank_points: long\n\n-RECORD 0----------------------------------\n tourney_id         | 1968-W-OL-MEX-01A... \n tourney_name       | Guadalajara Olymp... \n surface            | Clay                 \n draw_size          | {13, null}           \n tourney_level      | O                    \n tourney_date       | 19681014             \n match_num          | 1                    \n winner_id          | 200781               \n winner_seed        |                      \n winner_entry       |                      \n winner_name        | Edda Buding          \n winner_hand        | R                    \n winner_ioc         | FRG                  \n winner_age         | 31.9                 \n loser_id           | 200795               \n loser_seed         |                      \n loser_entry        |                      \n loser_name         | Patricia Montano     \n loser_hand         | U                    \n loser_ioc          | MEX                  \n loser_age          | 16.1                 \n score              | 7-5 2-6 6-4          \n best_of            | 3                    \n round              | R16                  \n winner_ht          | null                 \n loser_ht           | null                 \n minutes            | null                 \n w_ace              | null                 \n w_df               | null                 \n w_svpt             | null                 \n w_1stin            | null                 \n w_1stwon           | null                 \n w_2ndwon           | null                 \n w_svgms            | null                 \n w_bpsaved          | null                 \n w_bpfaced          | null                 \n l_ace              | null                 \n l_df               | null                 \n l_svpt             | null                 \n l_1stin            | null                 \n l_1stwon           | null                 \n l_2ndwon           | null                 \n l_svgms            | null                 \n l_bpsaved          | null                 \n l_bpfaced          | null                 \n winner_rank        | null                 \n winner_rank_points | null                 \n loser_rank         | null                 \n loser_rank_points  | null                 \nonly showing top 1 row\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Resolve the 'draw_size' type of choice (between long and string) in WTA data",
				"metadata": {}
			},
			{
				"cell_type": "code",
				"source": "# Print unique 'draw_size' values\nunique_values = wta_matches_df.select('draw_size').distinct().collect()\nfor row in unique_values:\n    try:\n        print(row[0][0])\n    except Exception as e:\n        print(e)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 52,
				"outputs": [
					{
						"name": "stdout",
						"text": "28\n30\n32\n4\n6\n24\n12\n48\n43\n40\n27\n'NoneType' object is not subscriptable\n8\n31\n25\n15\n64\n16\n96\nNone\n33\n56\n47\n62\n44\n5\n9\n128\n23\n2\n29\n80\n26\n20\n60\n21\n22\n55\n54\n58\n50\n51\n7\n61\n13\n57\n49\n10\n97\n41\n14\n45\n18\n19\n17\n11\n59\n38\n120\n53\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "# Cast all 'draw_size' to long, if not castable then set to null\ndyf = dyf.resolveChoice(specs = [('draw_size', 'cast:long')])\ndyf.printSchema()\nwta_matches_df = dyf.toDF()",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 53,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n|-- tourney_id: string\n|-- tourney_name: string\n|-- surface: string\n|-- draw_size: long\n|-- tourney_level: string\n|-- tourney_date: long\n|-- match_num: long\n|-- winner_id: long\n|-- winner_seed: string\n|-- winner_entry: string\n|-- winner_name: string\n|-- winner_hand: string\n|-- winner_ioc: string\n|-- winner_age: double\n|-- loser_id: long\n|-- loser_seed: string\n|-- loser_entry: string\n|-- loser_name: string\n|-- loser_hand: string\n|-- loser_ioc: string\n|-- loser_age: double\n|-- score: string\n|-- best_of: long\n|-- round: string\n|-- winner_ht: long\n|-- loser_ht: long\n|-- minutes: long\n|-- w_ace: long\n|-- w_df: long\n|-- w_svpt: long\n|-- w_1stin: long\n|-- w_1stwon: long\n|-- w_2ndwon: long\n|-- w_svgms: long\n|-- w_bpsaved: long\n|-- w_bpfaced: long\n|-- l_ace: long\n|-- l_df: long\n|-- l_svpt: long\n|-- l_1stin: long\n|-- l_1stwon: long\n|-- l_2ndwon: long\n|-- l_svgms: long\n|-- l_bpsaved: long\n|-- l_bpfaced: long\n|-- winner_rank: long\n|-- winner_rank_points: long\n|-- loser_rank: long\n|-- loser_rank_points: long\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Resolve duplicate player IDs between ATP and WTA data",
				"metadata": {
					"tags": []
				}
			},
			{
				"cell_type": "code",
				"source": "from pyspark.sql import functions as F\n\n# Get the maximum player_id from atp_players_df\nmax_atp_player_id = atp_players_df.agg({\"player_id\": \"max\"}).collect()[0][0]\nprint(max_atp_player_id)\n\n\nfrom pyspark.sql.window import Window\n\n# Create a window function to generate new IDs starting from max_atp_player_id + 1\nw = Window.orderBy(F.monotonically_increasing_id())\n\n# Add a new column 'new_player_id' starting from (max_atp_player_id + 1) and rename/drop columns\nwta_players_df = wta_players_df.withColumn('new_player_id', F.row_number().over(w) + max_atp_player_id) \\\n                               .withColumnRenamed('player_id', 'old_player_id') \\\n                               .withColumnRenamed('new_player_id', 'player_id')\nwta_players_df.printSchema()\nwta_players_df.show(n=5)\n",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 54,
				"outputs": [
					{
						"name": "stdout",
						"text": "212573\nroot\n |-- old_player_id: long (nullable = true)\n |-- name_first: string (nullable = true)\n |-- name_last: string (nullable = true)\n |-- hand: string (nullable = true)\n |-- ioc: string (nullable = true)\n |-- wikidata_id: string (nullable = true)\n |-- dob: long (nullable = true)\n |-- height: long (nullable = true)\n |-- player_id: integer (nullable = false)\n\n+-------------+----------+---------+----+---+-----------+--------+------+---------+\n|old_player_id|name_first|name_last|hand|ioc|wikidata_id|     dob|height|player_id|\n+-------------+----------+---------+----+---+-----------+--------+------+---------+\n|       113190|     Bobby|    Riggs|   U|USA|           |    null|  null|   212574|\n|       200000|         X|        X|   U|UNK|           |19000000|  null|   212575|\n|       200001|   Martina|   Hingis|   R|SUI|    Q134720|19800930|   170|   212576|\n|       200002|   Mirjana|    Lucic|   R|CRO|    Q239686|19820309|   181|   212577|\n|       200003|   Justine|    Henin|   R|BEL|     Q11682|19820601|   167|   212578|\n+-------------+----------+---------+----+---+-----------+--------+------+---------+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "# DataFrame wta_rankings: Change 'player' column to 'player_id'\nwta_rankings_df = wta_rankings_df.join(wta_players_df, on=wta_rankings_df.player == wta_players_df.old_player_id, how='left') \\\n                                 .select(wta_rankings_df['*'], wta_players_df['player_id']) \\\n                                 .drop('player')\nwta_rankings_df.printSchema()\nwta_rankings_df.show(n=5)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 55,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n |-- ranking_date: long (nullable = true)\n |-- rank: long (nullable = true)\n |-- points: long (nullable = true)\n |-- tours: long (nullable = true)\n |-- player_id: integer (nullable = true)\n\n+------------+----+------+-----+---------+\n|ranking_date|rank|points|tours|player_id|\n+------------+----+------+-----+---------+\n|    19840102|   4|  null| null|   212972|\n|    19840102|   5|  null| null|   212935|\n|    19840102|   2|  null| null|   212834|\n|    19840102|   3|  null| null|   212956|\n|    19840102|   6|  null| null|   212941|\n+------------+----+------+-----+---------+\nonly showing top 5 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "# DataFrame wta_matches: Change 'winner_id' and 'loser_id' columns to follow the new 'player_id'\nwta_matches_df = wta_matches_df.join(wta_players_df, on=wta_matches_df.winner_id == wta_players_df.old_player_id, how='left') \\\n                               .select(wta_matches_df['*'], wta_players_df['player_id']) \\\n                               .drop('winner_id') \\\n                               .withColumnRenamed('player_id', 'winner_id')\nwta_matches_df = wta_matches_df.join(wta_players_df, on=wta_matches_df.loser_id == wta_players_df.old_player_id, how='left') \\\n                               .select(wta_matches_df['*'], wta_players_df['player_id']) \\\n                               .drop('loser_id') \\\n                               .withColumnRenamed('player_id', 'loser_id')\nwta_matches_df.printSchema()\nwta_matches_df.show(n=1, vertical=True)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 56,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n |-- tourney_id: string (nullable = true)\n |-- tourney_name: string (nullable = true)\n |-- surface: string (nullable = true)\n |-- draw_size: long (nullable = true)\n |-- tourney_level: string (nullable = true)\n |-- tourney_date: long (nullable = true)\n |-- match_num: long (nullable = true)\n |-- winner_seed: string (nullable = true)\n |-- winner_entry: string (nullable = true)\n |-- winner_name: string (nullable = true)\n |-- winner_hand: string (nullable = true)\n |-- winner_ioc: string (nullable = true)\n |-- winner_age: double (nullable = true)\n |-- loser_seed: string (nullable = true)\n |-- loser_entry: string (nullable = true)\n |-- loser_name: string (nullable = true)\n |-- loser_hand: string (nullable = true)\n |-- loser_ioc: string (nullable = true)\n |-- loser_age: double (nullable = true)\n |-- score: string (nullable = true)\n |-- best_of: long (nullable = true)\n |-- round: string (nullable = true)\n |-- winner_ht: long (nullable = true)\n |-- loser_ht: long (nullable = true)\n |-- minutes: long (nullable = true)\n |-- w_ace: long (nullable = true)\n |-- w_df: long (nullable = true)\n |-- w_svpt: long (nullable = true)\n |-- w_1stin: long (nullable = true)\n |-- w_1stwon: long (nullable = true)\n |-- w_2ndwon: long (nullable = true)\n |-- w_svgms: long (nullable = true)\n |-- w_bpsaved: long (nullable = true)\n |-- w_bpfaced: long (nullable = true)\n |-- l_ace: long (nullable = true)\n |-- l_df: long (nullable = true)\n |-- l_svpt: long (nullable = true)\n |-- l_1stin: long (nullable = true)\n |-- l_1stwon: long (nullable = true)\n |-- l_2ndwon: long (nullable = true)\n |-- l_svgms: long (nullable = true)\n |-- l_bpsaved: long (nullable = true)\n |-- l_bpfaced: long (nullable = true)\n |-- winner_rank: long (nullable = true)\n |-- winner_rank_points: long (nullable = true)\n |-- loser_rank: long (nullable = true)\n |-- loser_rank_points: long (nullable = true)\n |-- winner_id: integer (nullable = true)\n |-- loser_id: integer (nullable = true)\n\n-RECORD 0----------------------------------\n tourney_id         | 1970-W-SL-AUS-01A... \n tourney_name       | Australian Open      \n surface            | Grass                \n draw_size          | 43                   \n tourney_level      | G                    \n tourney_date       | 19700119             \n match_num          | 2                    \n winner_seed        |                      \n winner_entry       |                      \n winner_name        | Helen Amos           \n winner_hand        | R                    \n winner_ioc         | AUS                  \n winner_age         | 21.5                 \n loser_seed         |                      \n loser_entry        |                      \n loser_name         | Caroline Cooper      \n loser_hand         | U                    \n loser_ioc          | AUS                  \n loser_age          | null                 \n score              | 6-0 6-3              \n best_of            | 3                    \n round              | R64                  \n winner_ht          | null                 \n loser_ht           | null                 \n minutes            | null                 \n w_ace              | null                 \n w_df               | null                 \n w_svpt             | null                 \n w_1stin            | null                 \n w_1stwon           | null                 \n w_2ndwon           | null                 \n w_svgms            | null                 \n w_bpsaved          | null                 \n w_bpfaced          | null                 \n l_ace              | null                 \n l_df               | null                 \n l_svpt             | null                 \n l_1stin            | null                 \n l_1stwon           | null                 \n l_2ndwon           | null                 \n l_svgms            | null                 \n l_bpsaved          | null                 \n l_bpfaced          | null                 \n winner_rank        | null                 \n winner_rank_points | null                 \n loser_rank         | null                 \n loser_rank_points  | null                 \n winner_id          | 212763               \n loser_id           | 212747               \nonly showing top 1 row\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Join up ATP and WTA data",
				"metadata": {}
			},
			{
				"cell_type": "code",
				"source": "# Merge ATP and WTA players data (drop 'old_player_id' from WTA data first)\nwta_players_df = wta_players_df.drop('old_player_id')\nplayers_df = atp_players_df.union(wta_players_df)\n\n# Merge ATP and WTA rankings data (rename 'player' column to 'player_id' and add 'tours' column to ATP data)\nfrom pyspark.sql.functions import lit\natp_rankings_df = atp_rankings_df.withColumnRenamed('player', 'player_id')\natp_rankings_df = atp_rankings_df.withColumn('tours', lit(None).cast('int'))\nrankings_df = atp_rankings_df.union(wta_rankings_df)\n\n# Merge ATP and WTA matches data\nmatches_df = atp_matches_df.union(wta_matches_df)",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 57,
				"outputs": [
					{
						"name": "stdout",
						"text": "\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Change the dates fields to DateType",
				"metadata": {}
			},
			{
				"cell_type": "code",
				"source": "from pyspark.sql.functions import col, to_date\nplayers_df = players_df.withColumn('dob', to_date(col('dob'), 'yyyyMMdd'))\nrankings_df = rankings_df.withColumn('ranking_date', to_date(col('ranking_date'), 'yyyyMMdd'))\nmatches_df = matches_df.withColumn('tourney_date', to_date(col('tourney_date'), 'yyyyMMdd'))",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 58,
				"outputs": [
					{
						"name": "stdout",
						"text": "\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "players_df.printSchema()",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 59,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n |-- player_id: string (nullable = true)\n |-- name_first: string (nullable = true)\n |-- name_last: string (nullable = true)\n |-- hand: string (nullable = true)\n |-- dob: date (nullable = true)\n |-- ioc: string (nullable = true)\n |-- height: long (nullable = true)\n |-- wikidata_id: string (nullable = true)\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Create new columns - winner games and loser games (from 'score')",
				"metadata": {}
			},
			{
				"cell_type": "code",
				"source": "from pyspark.sql.functions import expr\n\n# Split the 'score' string by empty space and save as an array\nmatches_df = matches_df.withColumn('split_score', F.split('score', ' '))\n\n# Extract the first character of each element in the array, cast to int, and sum\nmatches_df = matches_df.withColumn('winner_games', F.expr(\"aggregate(split_score, 0, (acc, x) -> acc + cast(substr(x, 1, 1) as int))\"))\n\n# Extract the last character of each element in the array, cast to int, and sum\nmatches_df = matches_df.withColumn('loser_games', F.expr(\"aggregate(split_score, 0, (acc, x) -> acc + cast(substr(x, -1, 1) as int))\"))\n\nmatches_df = matches_df.drop('split_score')\n\nmatches_df.show(n=2, vertical=True)\n",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 60,
				"outputs": [
					{
						"name": "stdout",
						"text": "-RECORD 0-----------------------------\n tourney_id         | 1968-2029       \n tourney_name       | Dublin          \n surface            | Grass           \n draw_size          | 32              \n tourney_level      | A               \n tourney_date       | 1968-07-08      \n match_num          | 270             \n winner_id          | 112411          \n winner_entry       |                 \n winner_name        | Doug Smith      \n winner_hand        | U               \n winner_ht          | null            \n winner_ioc         | AUS             \n winner_age         | null            \n loser_id           | 110196          \n loser_entry        |                 \n loser_name         | Peter Ledbetter \n loser_hand         | U               \n loser_ht           | null            \n loser_ioc          | IRL             \n loser_age          | 24.0            \n score              | 6-1 7-5         \n best_of            | 3               \n round              | R32             \n minutes            | null            \n w_ace              | null            \n w_df               | null            \n w_svpt             | null            \n w_1stin            | null            \n w_1stwon           | null            \n w_2ndwon           | null            \n w_svgms            | null            \n w_bpsaved          | null            \n w_bpfaced          | null            \n l_ace              | null            \n l_df               | null            \n l_svpt             | null            \n l_1stin            | null            \n l_1stwon           | null            \n l_2ndwon           | null            \n l_svgms            | null            \n l_bpsaved          | null            \n l_bpfaced          | null            \n winner_rank        | null            \n winner_rank_points | null            \n loser_rank         | null            \n loser_rank_points  | null            \n loser_seed         | null            \n winner_seed        | null            \n split_score        | [6-1, 7-5]      \n winner_games       | 13              \n loser_games        | 6               \n-RECORD 1-----------------------------\n tourney_id         | 1968-2029       \n tourney_name       | Dublin          \n surface            | Grass           \n draw_size          | 32              \n tourney_level      | A               \n tourney_date       | 1968-07-08      \n match_num          | 271             \n winner_id          | 126914          \n winner_entry       |                 \n winner_name        | Louis Pretorius \n winner_hand        | R               \n winner_ht          | null            \n winner_ioc         | RSA             \n winner_age         | null            \n loser_id           | 209536          \n loser_entry        |                 \n loser_name         | Maurice Pollock \n loser_hand         | U               \n loser_ht           | null            \n loser_ioc          | IRL             \n loser_age          | null            \n score              | 6-1 6-1         \n best_of            | 3               \n round              | R32             \n minutes            | null            \n w_ace              | null            \n w_df               | null            \n w_svpt             | null            \n w_1stin            | null            \n w_1stwon           | null            \n w_2ndwon           | null            \n w_svgms            | null            \n w_bpsaved          | null            \n w_bpfaced          | null            \n l_ace              | null            \n l_df               | null            \n l_svpt             | null            \n l_1stin            | null            \n l_1stwon           | null            \n l_2ndwon           | null            \n l_svgms            | null            \n l_bpsaved          | null            \n l_bpfaced          | null            \n winner_rank        | null            \n winner_rank_points | null            \n loser_rank         | null            \n loser_rank_points  | null            \n loser_seed         | null            \n winner_seed        | null            \n split_score        | [6-1, 6-1]      \n winner_games       | 12              \n loser_games        | 2               \nonly showing top 2 rows\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "code",
				"source": "matches_df.printSchema()",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 61,
				"outputs": [
					{
						"name": "stdout",
						"text": "root\n |-- tourney_id: string (nullable = true)\n |-- tourney_name: string (nullable = true)\n |-- surface: string (nullable = true)\n |-- draw_size: long (nullable = true)\n |-- tourney_level: string (nullable = true)\n |-- tourney_date: date (nullable = true)\n |-- match_num: long (nullable = true)\n |-- winner_id: string (nullable = true)\n |-- winner_entry: string (nullable = true)\n |-- winner_name: string (nullable = true)\n |-- winner_hand: string (nullable = true)\n |-- winner_ht: string (nullable = true)\n |-- winner_ioc: string (nullable = true)\n |-- winner_age: string (nullable = true)\n |-- loser_id: string (nullable = true)\n |-- loser_entry: string (nullable = true)\n |-- loser_name: string (nullable = true)\n |-- loser_hand: string (nullable = true)\n |-- loser_ht: double (nullable = true)\n |-- loser_ioc: string (nullable = true)\n |-- loser_age: double (nullable = true)\n |-- score: string (nullable = true)\n |-- best_of: long (nullable = true)\n |-- round: string (nullable = true)\n |-- minutes: long (nullable = true)\n |-- w_ace: long (nullable = true)\n |-- w_df: long (nullable = true)\n |-- w_svpt: long (nullable = true)\n |-- w_1stin: long (nullable = true)\n |-- w_1stwon: long (nullable = true)\n |-- w_2ndwon: long (nullable = true)\n |-- w_svgms: long (nullable = true)\n |-- w_bpsaved: long (nullable = true)\n |-- w_bpfaced: long (nullable = true)\n |-- l_ace: long (nullable = true)\n |-- l_df: long (nullable = true)\n |-- l_svpt: long (nullable = true)\n |-- l_1stin: long (nullable = true)\n |-- l_1stwon: long (nullable = true)\n |-- l_2ndwon: long (nullable = true)\n |-- l_svgms: long (nullable = true)\n |-- l_bpsaved: long (nullable = true)\n |-- l_bpfaced: long (nullable = true)\n |-- winner_rank: long (nullable = true)\n |-- winner_rank_points: long (nullable = true)\n |-- loser_rank: long (nullable = true)\n |-- loser_rank_points: long (nullable = true)\n |-- loser_seed: long (nullable = true)\n |-- winner_seed: long (nullable = true)\n |-- split_score: array (nullable = true)\n |    |-- element: string (containsNull = false)\n |-- winner_games: integer (nullable = true)\n |-- loser_games: integer (nullable = true)\n",
						"output_type": "stream"
					}
				]
			},
			{
				"cell_type": "markdown",
				"source": "#### Write the data to a new mazon S3 bucket and create an AWS Glue Data Catolog for it",
				"metadata": {}
			},
			{
				"cell_type": "code",
				"source": "# Write the DataFrames to S3 in a parquet format\nmatches_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/matches\")\nplayers_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/players\")\nrankings_df.write.format(\"parquet\").save(\"s3://processed-tennis-stats-data/rankings\")",
				"metadata": {
					"trusted": true,
					"tags": []
				},
				"execution_count": 63,
				"outputs": [
					{
						"name": "stdout",
						"text": "\n",
						"output_type": "stream"
					}
				]
			}
		]
	}
}